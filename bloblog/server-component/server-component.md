\*\* 내용이 생각보다 많아 2주로 나누어 작성하였습니다!

## 서버 컴포넌트

### 왜 서버 컴포넌트인가?

- Next.js 는 컴포넌트의 목적에 따라 어디에서 렌더링할지 선택할 수 있는 유연성을 제공
- 페이지를 더 작은 컴포넌트로 분리하면 대부분의 컴포넌트는 상호작용적이지 않음
  - 서버 컴포넌트로 서버에서 렌더링 + 작은 상호작용 UI에 대해서는 클라이언트 컴포넌트를 사용 하는 방식을 채택
- 사용 시 장점
  - 성능 최적화 : 초기 페이지 로드 속도 향상 및 클라이언트 자바스크립트 번들 크기 축소
  - 서버 자원 활용 : 데이터 가져오는 작업 등을 서버에서 처리 가능하고 큰 의존성을 서버 측에서만 로드하고 실행할 수 있음
  - 확장성: 애플리케이션이 커져도 클라이언트 번들 크기가 일정하게 유지되어 확장에 용이

### 클라이언트 컴포넌트

- `use client`를 파일 최상단에 정의
- 그 내부에 import되는 모든 모듈 및 자식 컴포넌트들은 클라이언트 번들의 일부

## 서버 컴포넌트 vs. 클라이언트 컴포넌트

### 사용 사례

|                             상황                              | 서버 컴포넌트 | 클라이언트 컴포넌트 |
| :-----------------------------------------------------------: | :-----------: | :-----------------: |
|                        데이터 가져오기                        |      ✔️       |                     |
|                    백엔드 자원에 직접 접근                    |      ✔️       |                     |
|            민감한 정보(접근 토큰, API 키 등) 접근             |      ✔️       |                     |
|         상호작용과 이벤트 리스너(`onClick()`등) 추가          |               |         ✔️          |
| 상태 관리나 생명 주기 훅(`useState()`, `useEffect()` 등) 사용 |               |         ✔️          |
|                    브라우저 전용 API 사용                     |               |         ✔️          |
|       브라우저 전용 API에 의존하는 사용자 정의 훅 사용        |               |         ✔️          |
|                     클래스 컴포넌트 사용                      |               |         ✔️          |

### 패턴

> ✅ 클라이언트 컴포넌트를 리프 노드로 이동하기

- 성능 향상을 위해 상호작용이 필요한 클라이언트 컴포넌트는 최대한 리프 노드에 배치해야 함
- e.g. 전체 레이아웃을 클라이언트 컴포넌트로 감싸는 대신 `SearchBar`(클라이언트)와 `Logo`(서버)를 구분하여 사용

```jsx
import SearchBar from "./searchbar";
import Logo from "./logo";

export default function Layout({ children }) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  );
}
```

> ✅ 클라이언트 + 서버 컴포넌트 병행하기

<aside>

    👀 React의 렌더링 흐름

    서버) 클라이언트에 결과를 보내기 전에 모든 서버 컴포넌트를 렌더링
    - 클라이언트 컴포넌트 내에 중첩된 서버 컴포넌트도 포함함
    - 이 단계에서 발생하는 클라이언트 컴포넌트는 건너뜀

    클라이언트) 클라이언트 컴포넌트를 렌더링, 서버 컴포넌트의 렌더링 결과를 삽입, 서버와 클라이언트에서 수행된 작업을 병합

</aside>

- 서버 컴포넌트는 서버에서 렌더링 후 결과를 props 등으로 클라이언트에 전달
- 클라이언트 컴포넌트는 클라이언트에서 렌더링 + 내부 서버 컴포넌트의 렌더링 결과 삽입

> 🔥 제한사항 : 클라이언트 컴포넌트에서 서버 컴포넌트를 직접 import하여 사용 불가

- 이미 서버에서 렌더링 된 컴포넌트를 `import` 로 다시 요청하는 구조이기 때문에 지원 x
- 대안 → 서버 컴포넌트를 props로 클라이언트 컴포넌트에 전달

  - 클라이언트 컴포넌트는 props가 무엇인지 알지 못하고, 렌더링 위치만 결정
  - 부모 서버 컴포넌트에서 클라이언트 컴포넌트를 감싸고, 서버 컴포넌트를 자식으로 전달하여 독립적인 렌더링 수행

  ```jsx
  "use client";

  import { useState } from "react";

  export default function ExampleClientComponent({ children }) {
    const [count, setCount] = useState(0);

    return (
      <>
        <button onClick={() => setCount(count + 1)}>{count}</button>

        {children}
      </>
    );
  }
  ```

  +) 서버에서 클라이언트 컴포넌트로 전달되는 Props는 직렬화 가능해야 함 (함수나 Date 객체 등을 직접 전달하지 못함)
