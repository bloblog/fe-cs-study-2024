> [테코톡 레모네의 웹소켓](https://www.youtube.com/watch?v=SwLKZUj9urY) 을 듣고 정리한 내용입니다

## 목차

1. [웹 소켓 등장 배경](#웹-소켓-등장-배경)
   - [Polling](#polling)
   - [Long Polling](#long-polling)
   - [Streaming](#streaming)
2. [웹 소켓이란](#웹-소켓이란)
   - [HTTP와 Web Socket 비교](#http와-web-socket-비교)
   - [웹 소켓 특징](#웹-소켓-특징)
   - [웹 소켓 단점](#웹-소켓-단점)
     - [STOMP](#stomp)
     - [Socket.io와 SockJS 라이브러리](#socketio와-sockjs-라이브러리)
3. [웹 소켓 프로토콜 통신 과정](#웹-소켓-프로토콜-통신-과정)
   - [오프닝 핸드쉐이크](#1️⃣-웹-소켓-커넥션을-잇는-오프닝-핸드쉐이크)
   - [양방향 데이터 전송](#2️⃣-클라이언트와-서버-사이의-양방향-데이터-전송)
   - [클로징 핸드쉐이크](#3️⃣-클로징-요청이-도착하면-웹-소켓-커넥션을-종료하는-클로징-핸드쉐이크)

## 웹 소켓 등장 배경

- **HTTP 통신**에서 서버는 클라이언트 **요청** 없이 **응답**할 수 **없다**
- 그렇다면 실시간으로 데이터가 변화하는 서비스에서는 HTTP 통신을 사용할 수 없을까?
- **Polling, Long Polling, Streaming**이라는 기능으로 HTTP를 사용해서도 실시간 통신을 할 수 있다
- 하지만 이 세 가지 방식은 **서버와 클라이언트가 “동시에” 통신할 수 없다**는 공통적인 문제점이 있다
- 이 점을 보완하고자 Web Socket이 등장하게 된다

### Polling
- 클라이언트가 서버에게 일정한 간격으로 요청을 보내서 이벤트가 발생했는지 물어보는 방식.
  
- 단점
    - 트래픽 낭비
        - 서버에게서 메일이 도착했는지 확인하기 위해 불필요한 요청이 굉장히 많이 필요하고 이는 트래픽 낭비로 이어질 수 있다
    - 요청 주기로 인한 실시간성 확보 어려움
        - 서버는 응답을 하고 클라이언트가 다음 요청을 하기까지의 빈 구간이 발생하는데,
        - 만약 해당 구간에서 이벤트가 발생하면 실제로 메일이 도착한 시기와 클라이언트가 메일을 알게 되는 시기 사이에 오차가 발생하게 된다
    - HTTP 오버헤드
        - HTTP 특성상 요청을 보내거나 응답을 보낼 때 헤더의 정보가 함께 전송되는데,
        - 만약 요청이 늘어나게 되면 이 헤더의 양도 많아지게 된다
        - 결국 우리가 알고자 하는 데이터 양은 굉장히 작지만, 이 헤더의 양 때문에 오버헤드라는 현상이 발생하게 된다

### Long Polling

- Polling 방식의 단점을 보완
- 클라이언트가 서버에게 요청하면, 서버가 바로 응답하지 않고 이벤트가 발생할 때까지 대기하다가, 이벤트가 발생하면 그때 서버가 응답한다.
  
- 장점
    - Polling에 비해 불필요한 요청이 감소된다
    - Polling에 비해 이벤트 응답 속도가 빠르다
- 단점
    - 클라이언트 수가 늘어나면 서버 부하가 발생할 수 있다 (서버가 이벤트가 발생할 때까지 클라이언트와의 커넥션을 계속 유지해야 해서, 클라이언트 수가 늘어나면 유지해야 할 커넥션 수도 늘어나기 때문)

### Streaming

- Server-Sent Event (SSE)
- 클라이언트가 요청하고, 서버는 이벤트가 발생하면 응답한다.
- 서버 응답 시 클라이언트가 재요청을 보내지 않고, 서버는 이벤트가 발생할 때마다 응답을 보낸다.
- 스트림이라는 작은 단위로 클라이언트에게 응답을 보내는데, 이 덕분에 여러 개의 스트림이 모여 하나의 응답이라는 방식으로 클라이언트의 요청 없이도 서버가 응답할 수 있게 된다.
  
- 단점
    - 클라이언트에 문제가 생겼을 때 서버가 알아채기 힘들다


## 웹 소켓이란

- 클라이언트와 서버 사이의 **양방향 통신**을 가능하게 한다
- 즉, 클라이언트와 서버가 **동시에 데이터를 송수신** 할 수 있다

## HTTP와 Web Socket 비교

- HTTP
    - **비연결성(Connectionless)**: 클라이언트가 요청을 보내고 서버가 다시 응답을 보내면 커넥션이 바로 종료된다
    - **무상태(Stateless)**: 클라이언트가 이전에 어떤 요청을 보냈는지 상태를 저장하지 않는다
      
- Web Socket
    - **연결유지(Connection):** 한 번 커넥션이 열리게 되면 커넥션을 종료하는 요청이 들어올 때까지 절대 종료되지 않는다
    - **상태유지(Stateful)**: 이전 클라이언트가 이전에 어떤 요청을 보냈는지 상태를 저장하고 있다

## 웹 소켓 특징

- HTML5에 새롭게 추가된 스택
- 텍스트와 바이너리(ex: 사진) 데이터를 **프레임** 단위로 송수신
- 서브 프로토콜 활용 (웹소켓은 최소화된 API이기 때문에 부족한 기능을 서버 프로토콜을 활용해 보완할 수 있음)
- 커스텀 URL **스킴** 사용
  
    - **스킴**
        - URL에서 해당 리소스를 어떻게 액세스하는지를 나타내는 부분
        - 어떤 프로토콜을 사용하는지
        - HTTP는 http, https라는 스킴을 사용
        - 웹 소켓은 WS, WSS라는 스킴을 사용

## 웹 소켓 단점

- 프레임에 대한 헤더가 존재하긴 하지만 구체적인 메시지 형식을 지정할 수 없다
    - ⇒ 메시지 형식을 지정하는 곳은 **STOMP 프로토콜**을 사용해서 극복!
      
- HTML5를 지원하지 않는 브라우저 버전이 존재하다면 웹소켓을 사용할 수 없다
    - ⇒ 웹 소켓을 사용할 수 없는 브라우저에서는 **Socket.io와 SockJS 라이브러리**를 활용하여 극복!

### **STOMP**

- Simple Text Oriented Message Protocol의 약자
- 텍스트 기반 메시지 프로토콜
- 채팅과 같은 서비스를 만들 때 자주 사용되는 프로토콜
- 메시지 종류, 형식, 메시지 내용 등을 정의
  
- publisher / subscriber 구조
    - 회원체(Client)는 먼저 특정 토픽에 대한 메시지를 전송하는 게시자(Publisher)와 특정 토픽을 구독하고 있는 구독자(Subscriber)로 나눌 수 있다
    - 만약 게시자가 특정 토픽에 대해 메시지를 전송하고자 하면, 해당 토픽을 구독하고 있는 모든 구독자들에게 토픽이 메시지를 전달해 준다
    - 토픽은 게시자와 구독자를 잇는 브로커의 역할을 한다

### **Socket.io와 SockJS 라이브러리**

- 특정 브라우저 버전에서 웹 소켓을 사용할 수 없다는 단점을 극복하기 위해 사용
- 웹 소켓의 연결에 실패할 시 **HTTP를 사용한 실시간 통신**으로 대체해 준다
  
- SockJS의 경우
    - 먼저 **웹 소켓** 연결을 시도하고
    - 웹 소켓 연결에 실패하면 **HTTP Streaming**으로 대체한다
    - 만약 Streaming 방식에도 실패하게 되면 **HTTP Long Polling** 방식으로 대체한다
      
- Spring Framework에서 SockJS를 공식적으로 지원해줌
    - spring-boot-starter-websocket 의존성 추가하면 STOMP와 SockJS를 사용 가능


## 웹 소켓 프로토콜 통신 과정

### 1️⃣ 웹 소켓 커넥션을 잇는 **오프닝 핸드쉐이크**
- 먼저 클라이언트는 서버에게 **HTTP 업그레이드 요청**을 보낸다 
    - = 웹 소켓 커넥션을 열어줘!
    - 아직 웹 소켓 커넥션이 열리지 않았기 때문에 시작은 HTTP 프로토콜을 사용했지만, 프로토콜을 업그레이드해서 웹 소켓으로 사용하겠다는 의미

- 서버에게 클라이언트 요청이 도착하면 서버는 HTTP 101을 응답한다
    - = 웹 소켓 커넥션을 열어줄게!
    - **Switching Protocols 101 상태 코드를 함께 전송**
        
- 웹소켓 커넥션 Open!

### 2️⃣ 클라이언트와 서버 사이의 **양방향 데이터 전송**
- 이제 클라이언트와 서버는 자유롭게 프레임 단위로 메시지를 전송할 수 있다.

### 3️⃣ 클로징 요청이 도착하면 웹 소켓 커넥션을 종료하는 **클로징 핸드쉐이크**
- 클로징 요청은 서버가 먼저 보낼 수도 있고 클라이언트가 먼저 보낼 수도 있다


## 마무리

웹 소켓은 **실시간 양방향 통신**이 필요한 **텍스트 기반** 서비스에 사용하면 좋다!
